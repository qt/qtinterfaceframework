/****************************************************************************
** Copyright (C) 2021 The Qt Company Ltd.
** Copyright (C) 2019 Luxoft Sweden AB
** Copyright (C) 2018 Pelagicore AG
** SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
****************************************************************************/
%option noyywrap
%option yylineno
%top{
// Copyright (C) 2021 The Qt Company Ltd.
// Copyright (C) 2019 Luxoft Sweden AB
// Copyright (C) 2018 Pelagicore AG
// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only

// This file was generated by flex - DO NOT EDIT!

//
//  W A R N I N G
//  -------------
//
// This file is not part of the Qt API.  It exists purely as an
// implementation detail. This header file may change from version to
// version without notice, or even be removed.
//
// We mean it.
//

#include <cassert>
#include <QtCore/QString>
#include <QtCore/QVariant>
#include <QtCore/QByteArray>

#ifdef Q_CC_MSVC
#   pragma warning(disable:4267)
#endif

#if __cplusplus > 199711L
#define register      // Deprecated in C++11.
#endif  // #if __cplusplus > 199711L

#define YY_NO_INPUT
#define YY_DECL int QIfQueryParser::nextToken()
#define YY_USER_INIT initBuffer()
#define YY_USER_ACTION calcCurrentColumn();
extern void readQueryBuffer(char* buffer,unsigned int& numBytesRead,int maxBytesToRead);
int isatty (int ) {
    return 0;
}
#define YY_INPUT(buf,result,max_size) \
    unsigned int res = result; \
    readQueryBuffer(buf, res, max_size); \
    result = res;
}

hex [0-9a-fA-F]
dec [1-9][0-9]*
oct [0-7]
digit [0-9]

fract [+-]?{digit}*\.{digit}+|{digit}+\.
exp [eE][+-]?{digit}+

hexfract {hex}*\.{hex}+|{hex}+\.
binexp [pP][+-]?{digit}+

icst [+-]?({dec}|0{oct}*|0[xX]{hex}+)

%%

"!" { return BANG; }
"!=" { return NE_OP; }
"(" { return LEFT_PAREN; }
")" { return RIGHT_PAREN; }
">" { return GT_OP; }
">=" { return GE_OP; }
"<" { return LT_OP; }
"<=" { return LE_OP; }
"||" { return OR_OP; }
"|" { return OR_OP2; }
"&&" { return AND_OP; }
"&" { return AND_OP2; }
"~=" { return IC_EQ_OP; }
"==" { return EQ_OP; }
"=" { return EQ_OP2; }

"/" { return ASCENDING; }
"\\" { return DESCENDING; }
"[" { return LEFT_BRACKET; }
"]" { return RIGHT_BRACKET; }

[_a-zA-Z][_a-zA-Z0-9]* {
  yylval = QVariant(QLatin1String(yytext));

  return IDENTIFIER;
}

\"(\\.|[^"])*\" {
  QString text = QLatin1String(yytext);
  text.truncate(text.size() - 1);
  yylval = text.mid(1);

  return STRING;
}

\'(\\.|[^'])*\' {
  QString text = QLatin1String(yytext);
  text.truncate(text.size() - 1);
  yylval = text.mid(1);

  return STRING;
}

{icst} {
  yylval = (int) strtol (yytext, 0, 0);
  return INTCONSTANT;
}

{fract}{exp}? {
  yylval = QByteArray::fromRawData(yytext, yyleng).toDouble();
  return FLOATCONSTANT;
}

{digit}+{exp} {
  yylval = QByteArray::fromRawData(yytext, yyleng).toDouble();
  return FLOATCONSTANT;
}

0[xX]{hexfract}{binexp} {
  yylval = QByteArray::fromRawData(yytext, yyleng).toDouble();
  return FLOATCONSTANT;
}

0[xX]{hex}+{binexp} {
  yylval = QByteArray::fromRawData(yytext, yyleng).toDouble();
  return FLOATCONSTANT;
}

[[:space:]]* {
    return SPACE;
}

. {
  return ERROR;
}


%%

