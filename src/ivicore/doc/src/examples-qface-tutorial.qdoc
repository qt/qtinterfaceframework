/****************************************************************************
**
** Copyright (C) 2019 Luxoft Sweden AB
** Contact: https://www.qt.io/licensing/
**
** This file is part of the documentation of the QtIvi module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:FDL-QTAS$
** Commercial License Usage
** Licensees holding valid commercial Qt Automotive Suite licenses may use
** this file in accordance with the commercial license agreement provided
** with the Software or, alternatively, in accordance with the terms
** contained in a written agreement between you and The Qt Company.  For
** licensing terms and conditions see https://www.qt.io/terms-conditions.
** For further information use the contact form at https://www.qt.io/contact-us.
**
** GNU Free Documentation License Usage
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file. Please review the following information to ensure
** the GNU Free Documentation License version 1.3 requirements
** will be met: https://www.gnu.org/licenses/fdl-1.3.html.
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
\example ivicore/qface-tutorial
\brief <<< ADD A GOOD BRIEF HERE >>>
\ingroup qtivicore-examples
\title Qt IVI Generator Tutorial
\image examples_qface_tutorial.png

This tutorial will show you how to extend your QML Application with your own autogenerated
middleware API. This will be done using a existing QML Instrument Cluster application and consists
of the following steps:

\list 1
    \li Basic Interface integration without backend, but with QML plugin ? (extra step ?)
    \li Extending the Interface, add annotations
    \li Adding a simulation backend (and simulation annotations) (explain linking)
    \li Adding a custom simulation behavior
    \li Adding a simulation server and using it from a qtro_backend
    \li Developing a production backend which connects to a dbus interface
\endlist

Before we start the actual Middleware integration, let's take a look at the existing Instrument
Cluster QML code and all the features it supports and our Middleware API should support as well.

\list
    \li \c images This folder contains all images used in the QML code
    \li \c Cluster.qml The main QML file assembling all other QML components together
    \li \c Dial.qml The base component for showing values like speed or rpm using a needle
    \li \c Fuel.qml A component to show the actual fuel level
    \li \c Label.qml A small helper component which sets all common settings used to display Text
    \li \c LeftDial.qml Shows the current speed using the Dial component and as Text and the current metric (mph or km/h)
    \li \c RightDial.qml Shows the current rpm and offers a way to show warning indicators.
    \li \c Top.qml The top bar showing the current Date and the current temperature.
\endlist

In the following chapters we will integrate the following features:
\list
    \li Show the current speed in the left dial
    \li Show the current rpm in the right dial
    \li Support to change between different metrics
    \li Show the current temperature in the top bar
    \li Show different warnings on the right dial
    \li Indicate whether the instrument cluster is connected and shows real data
\endlist

All this will be connected together to simulate a real driving experience and should look like
this:

\image examples_qface_tutorial_final.gif

\section1 Basic Middlware API with the help of IVI Generator

In this chapter we integrate a Middleware API into the existing Instrument Cluster QML code.
Instead of manually writing all parts ourself which is done in most other basic QML examples
(link), we will use the IVI Generator to autogenerate the needed parts.

\section2 Interface Definition Language

To be able to autogenerate the Middleware API the IVI Generator needs some input on what to
generate. This input is given in form of a Interface Definition Language (IDL) which describes the
API in a very simple form.

Let's start to define a very simple IDL which provides us with a speed property:

\quotefromfile ivicore/qface-tutorial/chapter1-basics/instrument-cluster.qface
\printuntil }

First, we need to define which module we want to describe. The module acts as a namespace, because
the IDL file can contain multiple interfaces.

\quotefromfile ivicore/qface-tutorial/chapter1-basics/instrument-cluster.qface
\printuntil module

The most important part of the module is its interface definition.

\quotefromfile ivicore/qface-tutorial/chapter1-basics/instrument-cluster.qface
\skipto interface
\printuntil }

In this case, we define an interface named InstrumentCluster consisting of one property. Each
property definition must contain at least a type and a name. Most of the basic types are built-in
and can be found in the QFace IDL syntax.

\section2 Autogeneration

Now as our first version of the IDL file is ready, it's time to autogenerate API out of it. This is
done by the IVI Generator tool. Similar to moc this autogeneration is integrated into the qmake
Build System and is done on compile time. In the following pro file we build a C++ library based on
our IDL file:

\quotefromfile ivicore/qface-tutorial/chapter1-basics/frontend/frontend.pro
\printto CONFIG += install_ok

Most of the qmake file is a standard setup to define a C++ library, using 'lib' TEMPLATE and
defining the wanted file name in the TARGET variable. The used qtLibraryTarget function helps to
correctly append the 'd' postfix on the filename for a library providing debugging information.
Because we need to link this file in the future we set the DESTDIR to the upper directory to make
this a bit easier (Windows is searching for libraries in the same directory automatically).

To activate the actual IVI Generator integration, the CONFIG needs to have the ivigenerator option.
By enabling this config the generator will be called during the build process using the qface file
provided in QFACE_SOURCES. See (link) for more information about the qmake integration.

Because we are building a library which is also supposed to work on Windows it's important to add
the QT_BUILD_EXAMPLE_IVI_INSTRUMENTCLUSTER_LIB to the DEFINES variable. This makes sure that all
symbols are exported when building the library, but imported when linking against it. See Creating
Shared Libraries for more information on this topic.

\section2 What will be autogenerated ?

The ivigenerator is based on generation templates. These templates define what content is generated
from the IDL file. When no QFACE_FORMAT is defined this will automatically default to use the
"frontend" template. What a template generates is explained here (link to the frontend template).

In short the 'frontend' template will generate a C++ class derived from QIviAbstractFeature for
every interface in the IDL file and one module class which helps to register all interfaces to QML
and which stores global types and functions for. More on that in a later chapter.

To inspect the C++ code yourself, you can either checkout the files in the build folder of your
library.

The most important file for us right now which is autogenerated is the resulting C++ class for our
defined interface. It looks like this:

\quotefile ivicore/qface-tutorial/chapter1-basics/frontend/instrumentcluster.h

As you can see does the autogenerated C++ class implement a "speed" property as defined in the IDL
file. By using the Q_OBJECT macro and Q_PROPERTY the class is already now ready to be used directly
in your QML code.

\section2 Integrating the frontend library into the QML code

The last part of this chapter is to use the autogenerated frontend library from the QML code. To
keep this integration simple we follow the standard Qt example way and use a small C++ main
function which registers our autogenerated types to QML and loads the Instrument Cluster QML code
into the QQmlApplicationEngine:

\quotefromfile ivicore/qface-tutorial/chapter1-basics/instrument-cluster/main.cpp
\skipto #include "instrumentclustermodule.h"
\printuntil }

What's still missing is the actual integration of the InstrumentCluster QML element and connecting
the speed property to the leftDial. This can be done by instantiating the element first with the id
instrumentCluster.

\quotefromfile ivicore/qface-tutorial/chapter1-basics/instrument-cluster/Cluster.qml
\skipto import
\printuntil InstrumentCluster
\printuntil }
\codeline

Now we can create a Binding for the value property of the LeftDial Item to the speed property of
our InstrumentCluster API.

\printuntil }

\section1 Chapter 2

In the second chapter we will extend our Middleware API with more properties, using enums and
defining our own struct.

\section2 Defining speed as readonly property

In the previous chapter we defined the speed property in our QFace IDL file in the following way:

\quotefromfile ivicore/qface-tutorial/chapter1-basics/instrument-cluster.qface
\printuntil }

Because we didn't use any extra specifier this property is defined as being readable and writable.
For our Instrument Cluster example having a writable speed property doesn't make much sense, as it
is not supposed to be used to accelerate the car, but just to visualize the current state.

We can define the property to be read only by using the "readonly" keyword.

\quotefromfile ivicore/qface-tutorial/chapter2-enums-structs/instrument-cluster.qface
\printuntil readonly
\skipto }
\printuntil }

Starting to build our app again, the build system will recognize the changed qface file and start
the IVI Generator to generate an updated version of the C++ code. After the IVI Generator is done
you can open the instrumentcluster.h from within the build folder and you will see that the
generated C++ property changed to NOT have any setter anymore and by that is now read only.

\quotefromfile ivicore/qface-tutorial/chapter2-enums-structs/frontend/instrumentcluster.h
\skipto class Q_EXAMPLE
\printuntil Q_PROPERTY
\dots
\skipto };
\printuntil };

\section2 Extending the interface

To reach our goal to provide a full simulation for the Instrument Cluster, we need to add more
properties to our IDL file. Adding additional properties for 'rpm', 'fuel' and 'temperature' should
be a easy job and result in this:

\quotefromfile ivicore/qface-tutorial/chapter2-enums-structs/instrument-cluster.qface
\printuntil readonly real temperature
\skipto }
\printuntil }

You might have noticed that we used a different type for the 'fuel' and 'temperature' properties.
We use the type real here as we would like to show the temperature as a floating point number and
the current fuel level between 0 and 1.

\section2 Defining a new enum type

As we like to be able to switch between the metric and the imperial system, we also need to define
a property for the system we currently use. Using a boolean property would work, but doesn't offer
a nice API, so we define a new type in the IDL and use it as the type for the new 'system'
property:

\quotefromfile ivicore/qface-tutorial/chapter2-enums-structs/instrument-cluster.qface
\printuntil readonly SystemType
\skipto }
\printuntil enum
\printuntil }

In the autogenerated code, this will create a enum which is part of the module class. This makes it
possible that the same enum can be used by multiple classes which are part of the same module:

\quotefile ivicore/qface-tutorial/chapter2-enums-structs/frontend/instrumentclustermodule.h

\section2 Add a new struct

To display warnings on the right dial of the Instrument Cluster we would like to use a struct which
stores color, icon and text of the warning instead of using 3 independent properties for this.
Similar to define a interface, we can use the struct keyword in the IDL file:

\quotefromfile ivicore/qface-tutorial/chapter2-enums-structs/instrument-cluster.qface
\skipto struct
\printuntil }

Using this new struct for as a type for a property works in the same way as when using a enum, the
final IDL file should now look like this:

\quotefile ivicore/qface-tutorial/chapter2-enums-structs/instrument-cluster.qface

\section2 Integrating the new properties

Like in the previous chapter, doing the actual integration of the new introduced properties should
be pretty straightforward by creating Bindings. The rpm property can be directly connected to the
value property of the rightDial Item and in the same way the temperature property of the top Item
can be connected. To control what unit is displayed in the left Dial, the leftDial Item provides a
bool property named metricSystem. As we used a enum in our IDL file we need to convert the value
first by testing the 'sytemType' property for the 'Metric' value.

\quotefromfile ivicore/qface-tutorial/chapter2-enums-structs/instrument-cluster/Cluster.qml
\skipto LeftDial
\printuntil }
\codeline

Like seen above the enums are part of the module class, which is also exported to QML as
InstrumentClusterModule. To trigger a warning in the rightDial Item, we can also use 3 bindings to
connect to the 3 member variables of the struct:

\printuntil }

\section1 Chapter 3

In the previous two chapters we wrote a Middleware API in form of a IDL file and used the IVI
Generator to autogenerate a C++ API in form of a library. In this chapter we will extend this by
introducing a simulation backend and use annotations to define default values for our simulation.

\section2 Frontend / Backend Separation

QtIvi and the IVI Generator enables you to write code which use a Frontend / Backend Separation.
Now what does that actually mean ? The separation is done to split an API from the actual
implementation of this API. Qt uses this already in a lot of areas, most prominently the underling
window system technology on the various supported Qt platforms e.g. xcb on linux and cocoa on mac.
The same separation is done for our Middleware API, where the frontend provides the API in form of
a library and the backend provides a implementation of this API. This is based on the Dynamic
backend System of QtIvi which enables to switch between such backends at runtime.

\image feature-backend.png

\section2 Adding a simulation Backend

For our Instrument Cluster we would like to add such a backend to provide actual values. For now we
would like to just have some simulation behavior as we can't connect it easily to a real car,
that's why such backends are called "simulation backend". To add such a backend we can use the help
of the IVI Generator again and let it do the heavy lifting for us and generate one. This is done in
a similar way as we already generated the library using the 'frontend' template, but we are now
using the 'backend_simulator' template:

\quotefromfile ivicore/qface-tutorial/chapter3-simulation-backend/backend_simulator/backend_simulator.pro
\printto DESTDIR
\skipto QT
\printuntil CONFIG
\skipto QFACE_FORMAT
\printto CONFIG += install_ok

Like for the frontend library, the project file builds a lib and defines the library name using
qtLibraryTarget to also support windows debug postfix. One important aspect here is that the
library name ends with '_simulation' which is a way to tell QtIvi that this is a simulation backend
and once a 'production' backend is available prefer to use this over the 'simulation'. See <link>
for more information on this.

Enable the IVI Generator is also done in the same way by using the same QFACE_SOURCE, but defining
QFACE_FORMAT to 'backend_simulator' to use the correct generation template. In addition we need to
add 'plugin' into the CONFIG variable to make this library a Qt plugin which can easily be loaded
at runtime.

\section2 Link settings and how plugins are found.

Trying to build the project file just as it is now, would result in compilation and linking errors.
The reason for that is, in order to do the Frontend / Backend Separation there needs to be a
defined interface class which needs to be implemented by the backend and is known to the frontend.
This interface is called 'backend interface' and is automatically generated as part of the frontend
library. Because this class provides signals and slots and uses QObject as the base class you need
to link to the frontend library when you inherit from it. As this is needed for the backend plugin,
we need to add the following lines in addition:

\quotefromfile ivicore/qface-tutorial/chapter3-simulation-backend/backend_simulator/backend_simulator.pro
\skipuntil CONFIG
\printuntil INCLUDEPATH

Now the project should build fine and create the plugin in your build folder (or the plugin folder
in case you don't use a shadow build). If you would start the Instrument Cluster again you should
still the following message:

\badcode
There is no production backend implementing "Example.IVI.InstrumentCluster.InstrumentCluster" .
There is no simulation backend implementing "Example.IVI.InstrumentCluster.InstrumentCluster" .
No suitable ServiceObject found.
\endcode

This indicates that QtIvi is still not able to find our just created simulation plugin. For this to
understand you need to know a little bit more about Qts Plugin System and how it it finds plugins.
Qt searches for it's plugins in multiple directories, the first one is the plugin folder which
comes with your Qt installation and is called 'plugins'. Within the plugins folder every plugin
type has it's own sub-folder e.g. 'platforms' for the platform plugins used to talk to the
underlying platform API and the windowing system. QtIvi searches for its backend plugins in the
'qtivi' folder. To make sure our simulation backend ends up in such a folder we add the following
DESTDIR definition.

\quotefromfile ivicore/qface-tutorial/chapter3-simulation-backend/backend_simulator/backend_simulator.pro
\skipto DESTDIR
\printuntil DESTDIR

You might wondering how creating a qtivi folder in the upper directory should solve this problem of
finding the plugin as it's not part of the system plugins folder. As said Qt supports searching in
multiple folder for such plugins and one of those folders is the path of the executable itself.
Another way would be to add an additional plugin path using the QCoreApplication::addLibraryPath()
function or using the QT_PLUGIN_PATH environment variable. See "How to create Qt Plugins" for more
information about this.

\section2 Exporting the QML types in a QML Plugin

In the first chapter we extended our main.cpp to register all types of our autogenerated Middleware
API. Although this works fine, in bigger projects it's common to use a QML Plugin instead and be
able to use qmlscene for the development. Although the code for doing this is relative simple, the
IVI Generator supports to do this as well and makes it even easier. We already learned in the first
chapter that for the QML import uri the module name is used. For a QML plugin this is important
as the QmlEngine expects the plugin on a specific folder following the module name, where every section
of the module name is a sub-folder. Our project file to generate a QML plugin looks like this:

\quotefromfile ivicore/qface-tutorial/chapter3-simulation-backend/imports/imports.pro
\printto target.path

All lines until QFACE_SOURCES should be know. We use CONFIG to build a plugin. Define settings for
the linker to link against our frontend library and use QFACE_FORMAT to define 'qmlplugin' as the
used generation template. Instead of adding 'ivigenerator' to CONFIG we use the load() function to
explicitly load the feature, this enables us to use the URI variable which is part of the 'qmlplugin'
generation template. This URI can be used to define a DESTDIR by replacing all dots with slashes.

In addition to the folder structure the QmlEngine also needs a qmldir file which indicates what
files are part of the plugin under which uri. See <link> for more information about this. This
qmldir file as well as a plugins.qmltypes files which provides information about code-completion is
autogenerated by the IVI Generator, but needs to be put next to the library. To do this we add
the files to a scope similar to a INSTALL target, but instead add it to the COPIES variable, which
makes sure the files are copied when building the plugin.

Now the plugin is ready to be used, but our Instrument Cluster application doesn't know where to
search for it and is still using the old hardcoded registration. We can now remove the linking step
in the instrument-cluster.pro file and change our main file to the following:

\quotefromfile ivicore/qface-tutorial/chapter1-basics/instrument-cluster/main.cpp
\skipto #include
\printuntil }

The important part which was changed is that we added an additional import path by using the
addImportPath function, which points to the 'imports' folder next to the binary location.

\section1 Chapter 4

So far we created a Middleware API and integrated it into our Instrument Cluster QML code, extended
it by using a QML plugin and generated a simulation backend. Quite a lot happened in the background
to support us, but on the UI side not much has changed till now. This chapter is about bringing our
simulation backend to life by defining sane default values and starting to simulate a real car
ride.

\section2 Defining default values

We will start by defining default values for our properties. This is done using annotations in our
qface IDL file. An annotation is a special kind of comment which adds extra data to a interface,
method, property etc. For this use case we will use the 'config_simulator' annotation. More
information what other kind of annotations are available can be found here. At the moment the
temperature of our Instrument Cluster defaults to 0. Lets change this to a spring temperature and
change it to 15 degree celsius. This is done by adding the following YAML fragment:

\quotefromfile ivicore/qface-tutorial/chapter4-simulation-behavior/instrument-cluster.qface
\printuntil }

After compiling the plugin again the temperature change should now be reflected in our Instrument
Cluster. Let's take a look how this actually works. What happened when starting the IVIGenerator is
that the config_simulator annotation was transformed into a JSON file which is now part of the
simulation backend build folder. This JSON file looks like this:

\quotefile ivicore/qface-tutorial/chapter4-simulation-behavior/backend_simulator/instrumentcluster.json

So how is this JSON file related to the actual simulation backend code ? The autogenerated
simulation backend code is using the QIviSimulationEngine. The QIviSimulationEngine reads the JSON
file and provides it's data to a QML simulation file. A default QML file is also autogenerated and
loaded from the QIviSimulationEngine. This QML file provides the behavior of what should happen in
the simulation backend. We will take a look at the QML file and how we can change in the next
section, let's first see how we can change the default values in a more dynamic fashion.

The QIviSimulationEngine allows us to override which JSON file should be loaded into the engine by
setting the QTIVI_SIMULATION_DATA_OVERRIDE environment variable. As there can be multiple engines
running by different backends we need to define which engine we mean. In the autogenerated code
always the module name is used as the engine specifier. For this chapter we already prepared a
second JSON file which is part of our source directory. Setting the environment variable like
follows, will change the systemType to Mph instead of km/h:

\badcode
QTIVI_SIMULATION_DATA_OVERRIDE=instrumentcluster=<path-to-file>/miles.json
\endcode

\section2 How to define a QML behavior ?

Before we define our own behavior, let's first take a look on what has been autogenerated already
for us: There are two QML files. The first file instrumentcluster_simulation.qml is the entry point
and just instantiates a InstrumentClusterSimulation.qml file. This is done as there can be multiple
interfaces defined as part of the same module. The InstrumentClusterSimulation.qml file is way more
interesting:

\quotefile ivicore/qface-tutorial/chapter4-simulation-behavior/backend_simulator/InstrumentClusterSimulation.qml

First there is a 'settings' property, this is initialised with the return value of the
IviSimulator.findData method, which takes the IviSimulator.simulationData and a string as input.
The simulationData is the JSON file represented as a JavaScript object. The findData method helps
us to extract just the data which is of interest for this interface. In this case for the
"InstrumentCluster". The following properties helps the behavior to know whether the default
values are set and a LoggingCategory to identify the log output of this simulation file.

Afterwards the actual behavior is defined by instantiating a InstrumentClusterBackend Item and
extending it with more functions. The InstrumentClusterBackend is our interface towards our
InstrumentCluster QML frontend class, but other than the frontend the properties are also writable
to make it possible to change them to provide a useful simulation.

Every time a frontend instance connects to a backend the initialize() function is called. The same
happens for the QML simulation, as the initialize() C++ function forwards this to the QML instance.
The same happens for all other functions like setter and getters for properties or the methods. See
QIviSimulationEngine for more information.

Inside the QML initialize() function we call the IviSimulator.initializeDefault() function, which
will read the default values from the simulationData object and initialises all properties. This is
only done once, as we don't want the properties be reset to default when the next frontend instance
connects to the backend. Last the base implementation is called to make sure the initializationDone
signal is sent to the frontend.

Similar a setter function is defined for every property. These setter functions use the
IviSimulator.checkSettings() function which reads specific constraint settings for the property
from the simulationData and checks whether these constraints are valid for the new value. In case
the constraints are not valid, the IviSimulator.constraint() function is used to provide a
meaningful error message to the user.

\section2 Defining our own QML simulation

As explained above does the InstrumentClusterBackend Item provide all the properties of our IDL
file. This can be used to simulate a behavior by changing the properties to the values we want.
This simplest form for this would be a value assignment, but this would be rather static and is not
what we would like to achieve. Instead we use QML Animation objects to change the values over time:

\quotefromfile ivicore/qface-tutorial/chapter4-simulation-behavior/backend_simulator/simulation.qml
\skipto NumberAnimation
\printuntil }

This will change the speed property to 80 over 4000 seconds and simulates a accelerating car.
Extending this to the other properties and by using sequential and parallel animations a full
simulation could look like this:

\quotefromfile ivicore/qface-tutorial/chapter4-simulation-behavior/backend_simulator/simulation.qml
\skipto property var animation
\printuntil property: "fuel"
\printuntil property: "fuel"
\printuntil }
\printuntil }

To also provide a nice simulation for the 'rpm' property, we use a binding which does some calculations
based on the current speed. The complete simulation file looks like this:

\quotefromfile ivicore/qface-tutorial/chapter4-simulation-behavior/backend_simulator/simulation.qml
\skipto import

The next step is to tell the IVI Generator and the QIviSimulationEngine about the new simulation file.
Similar to QML files, the best aproach here is to put the simulation file into a resource file. In
our example we added a new file called simulation.qrc which contains our simulation.qml using the
/ prefix.

This location now needs to be added in form of an annotation to our QFace file:

\quotefromfile ivicore/qface-tutorial/chapter4-simulation-behavior/instrument-cluster.qface
\printuntil module
\dots

Rebuilding the simulation backend now will embed the simulation file into the plugin and give the
file to the QIviSimulationEngine, which will start with the simulation once loaded.

\section1 Chapter 5

In this chapter we will extend our Instrument Cluster to use a IPC mechanism and use two processes.
At the moment the simulation is loaded as a plugin and because of that part of the same service.
Although this is good enough for a small example application, it is not how it works in modern
multi-process architectures, where multiple processes need to be able to access the same value and
react to changes. We could now write a second Application which is using the same Middleware API,
but instead we can achieve the same thing by just starting the Instrument Cluster twice and check
whether the animations are in sync, which they are not.

<< gif >> ????

\section2 Adding a QtRemoteObjects integration

The IPC for this example is QtRemoteObjects as the IVI Generator already provides support for this
out of the box. To use QtRemoteObjects we generate a second plugin, this time it is a "production"
backend and because of that automatically preferred over the simulation backend we introduced
before. This is done by the following project file:

\quotefromfile ivicore/qface-tutorial/chapter5-ipc/backend_qtro/backend_qtro.pro
\printto CONFIG += install_ok

This pro file looks almost identical to the pro file we used for our simulation backend. For now we
will just highlight what has been changed. The name for the plugin doesn't end with "_simulation"
to indicate that this is a "production" backend and the QFACE_FORMAT has been changed to
"backend_qtro" to generate a backend which uses QtRemoteObjects Replicas to connect to a
QtRemoteObjects Source providing the values.

In addition to a QtRemoteObject based backend, we also need a QtRemoteObject based server. This
part can also be autogenerated using the IVI Generator in a similar fashion:

\quotefromfile ivicore/qface-tutorial/chapter5-ipc/simulation_server/simulation_server.pro
\printto target.path

Because we would like to generate a server binary, the TEMPLATE needs to be set to app instead of
lib and similar to the plugin the server also needs to link against our library as it needs to have
access to the defined enums, structs and other types. The template we use to generate a simulation
server is called "server_qtro_simulator".

\section2 Reusing the existing simulation behavior

If you start the server now and then the Instrument Cluster you don't see the simulation anymore,
which we added in the previous chapter. The reason for this, is that the simulation code is part of
our simulation backend, but this backend is not used anymore as we added the QtRemoteObjects based
"production" backend.

Because we used the "server_qtro_simulator" generation template, this can easily be fixed, as the
generated server code is also using the QIviSimulationEngine and supports to use the same
simulation file than our simulation backend. We just need to extend the project file in the same
way as we did before and are also able to use the same resource file for this.

\quotefromfile ivicore/qface-tutorial/chapter5-ipc/simulation_server/simulation_server.pro
\skipto RESOURCES
\printuntil RESOURCES

In the same way we can also use the other simulation data JSON file we defined in the previous
chapter by using the same environment variable. We just need to pass it to the server instead of
our Instrument Cluster application.

Doing the final test, starting two Instrument Cluster instances should now show the animations in
sync:

<< gif >> ???

\section1 Chapter 6

In the previous chapter we extended our Instrument Cluster code by using QtRemoteObjects as IPC and
autogenerated a backend for it, as well as a server providing the simulation. In this chapter we
would like to manually write our own backend which is using DBus as IPC. For this we already
prepared a working D-Bus server which provides a very limited simulation.

Let's first take a short look at the server code and see what is done there and then write the
backend connecting to it.

\section2 D-Bus Server

As said above we will use D-Bus for this chapter and we already have a XML file describing the
D-Bus interface, similar to our qface IDL:

\quotefile ivicore/qface-tutorial/chapter6-own-backend/demo_server/instrumentcluster.xml

This xml file is used to let qmake generate a base class which is extended by the server with
actual functionality. See the QtDBus documentation for more information about this works in detail.

Our D-Bus server starts on the session bus on the / path and provides a interface name
"Example.IVI.InstrumentCluster". To simulate some values, we keep it simple and just use a timer
event to change the speed value each 100 milliseconds and start at 0 again once the maximum of 250
is reached. In a similar way the rpm value is increased until 5000. For all other properties we
simply provide hardcoded values.

\quotefromfile ivicore/qface-tutorial/chapter6-own-backend/demo_server/instrumentcluster.cpp
\skipto timerEvent
\printuntil }

\section2 Our own D-Bus Backend

Let's start with a project file for our backend. This is very similar to previous project files,
but doesn't use the IVI Generator, but instead uses DBUS_INTERFACES to autogenerate some client
code which sends and receives messages over D-Bus. First we need to define the entry point for our
plugin. This plugin class needs to derive from QIviServiceInterface and implement two functions:

\list
    \li \c {QStringList interfaces()} Returns a list of all interfaces supported by this plugin
    \li \c {QIviFeatureInterface *interfaceInstance(const QString &interface)} Returns a instance of the requested interface
\endlist

In addition we also need to provide the list of interfaces we support as plugin metadata in form of
a JSON file which looks like this:

\quotefile ivicore/qface-tutorial/chapter6-own-backend/backend_dbus/instrumentcluster_dbus.json

This is needed as it gives QtIvi the chance to know which interfaces a backend supports before
instantiating it and only load the plugins which are needed for by the app code.

Our plugin code looks like this:

\quotefromfile ivicore/qface-tutorial/chapter6-own-backend/backend_dbus/instrumentclusterplugin.cpp
\skipto #include
\printuntil eof

In interfaces() we use the IID which is defined in instrumentclusterbackendinterface.h from our
autogenerated library. In insterfaceInstance() we check for the correct string and return a
instance of our implemented instrument cluster backend.

This backend will be defined in instrumentclusterbackend.h and derives from
InstrumentClusterBackendInterface. In our InstrumentClusterBackend class we need to implement all
pure virtual functions from InstrumentClusterBackendInterface and derived classes. For our example
this is pretty simple, as we just need to implement the initialize() function. If our IDL would use
writable properties or methods, we would need to implement these as well. We don't need to
implement getters for our properties, because QtIvi uses the changed signals during the
initialization phase to get informed about the current state. Although the generated DBus interface
class would provides getters to retrieve the properties from our server, it is not recommended to
use these when developing a backend. These getters are implemented by using synchronous calls, which
means they will block the event loop until an answer is received by the client. This can lead to
performance issues and is the reason why we recommend to use async calls instead.

In our backend we define a fetch function for every property which is implemented like this:

\quotefromfile ivicore/qface-tutorial/chapter6-own-backend/backend_dbus/instrumentclusterbackend.cpp
\skipto ::fetchSpeed
\printto ::fetchRpm

First we add the property to a list to know which properties have been fetched successfully. In the
next step we use the asyncCall() function to call the getter for the 'speed' property and use a
QDBusPendingCallWatcher to wait for the result. Once the result is ready the lambda will remove the
property again from our fetchList use the onSpeedChanged() function to store the value and notify
the frontend about it. As we don't need the watcher anymore we delete it in the next event loop
run using deleteLater() and call the checkInitDone() function.

The checkInitDone() function is defined as follows:

\quotefromfile ivicore/qface-tutorial/chapter6-own-backend/backend_dbus/instrumentclusterbackend.cpp
\skipto ::checkInitDone
\printto onSpeedChanged

It makes sure the initializationDone() signal is sent to the frontend once all our properties were
fetched from the server and the initialization is complete.

In addition to retrieving the current state from the server, we also need to inform our frontend
about every property change. This is done by emitting the corresponding change signal once the
server changed one of it's properties. For this we define a slot for every property. This slot
will save the property in our class an emit the change signal:

\quotefromfile ivicore/qface-tutorial/chapter6-own-backend/backend_dbus/instrumentclusterbackend.cpp
\skipto void InstrumentClusterBackend::onSpeedChanged(int speed)
\printto onRpmChanged

The same slot is also used during the initialization phase to save and emit the value.

You might think now why saving the value is needed at all and why not just emit the signal. The
reason for this is that the backend plugin is used directly by every instance of the InstrumentCluster
class and every instance calls the initialize() function to retrieve the current state. Instead
of fetching all properties again the second initialize() call will just emit the already saved
values and the slots will keep them uptodate.

When starting the Instrument Cluster now, our backend should connect to our D-Bus server and now
look like this:

< gif >

*/
