// Copyright (C) 2021 The Qt Company Ltd.
// Copyright (C) 2019 Luxoft Sweden AB
// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR GFDL-1.3-no-invariants-only

/*!
    \example interfaceframework/qface-tutorial
    \brief Demonstrates step-by-step how to generate a Middleware API based on a QML application.
    \ingroup qtinterfaceframework-examples
    \title Qt Interface Framework Generator Tutorial
    \image qface-tutorial.png

    This tutorial demonstrates how you can extend a QML application with your own auto-generated
    Middleware API. We use an existing QML Instrument Cluster application and proceed through the
    following steps:

    \list 1
        \li \l{chapter1}{Integrate a basic interface without a back end}
        \li \l{chapter2}{Extend the interface and add annotations}
        \li \l{chapter3}{Add a simulation back end and corresponding simulation annotations; with a QML plugin}
        \li \l{chapter4}{Add a custom simulation behavior}
        \li \l{chapter5}{Add a simulation server and use it from a Qt Remote Objects back end}
        \li \l{chapter6}{Develop a production back end that connects to a DBus interface}
    \endlist

    Before we start the actual middleware integration, let's take a look at the existing Instrument
    Cluster QML code and all the features it supports:
    \list
        \li \c images -- This folder contains all images used in the QML code.
        \li \c Cluster.qml -- The main QML file that assembles all other QML components together.
        \li \c Dial.qml -- The base component to show values like speed or Revolutions per Minute
            (RPM), using a needle.
        \li \c Fuel.qml -- The component to show the actual fuel level.
        \li \c Label.qml -- A small helper component which sets all common settings used to display
            text.
        \li \c LeftDial.qml -- Shows the current speed using the Dial component and as text, as
            well as the current metric in miles per hour (mph) or kilometers per hour (km/h).
        \li \c RightDial.qml -- Shows the current RPM and offers a way to show warning indicators.
        \li \c Top.qml -- The top bar that shows the current date and the current temperature.
    \endlist

    Next, we use our Middleware API to add support for the following features:
    \list
        \li Show the current speed in the left dial.
        \li Show the current RPM in the right dial.
        \li Change between different metrics.
        \li Show the current temperature in the top bar.
        \li Show different warnings on the right dial.
        \li Indicate whether the instrument cluster is connected and show real data.
    \endlist

    The ultimate goal is to connect all of these features together to simulate a real-time driving
    experience like this:

    \image qface-tutorial-final.gif

    \target chapter1
    \section1 Chapter 1: Basic Middleware API with the Interface Framework Generator

    In this chapter we integrate a Middleware API into the existing Instrument Cluster QML code.
    Instead of manually writing all of these parts ourselves, which is done in most basic
    \l{https://doc.qt.io/qt-6/qtquick-codesamples.html}{QML examples}, we'll use the Interface Framework Generator
    to auto-generate the required parts.

    \target define-speed-property
    \section2 Interface Definition Language

    To be able to auto-generate the Middleware API, the Interface Framework Generator needs some input on what to
    generate. This input is given in form of an Interface Definition Language (IDL), QFace, which
    describes the API in a very simple way.

    Let's start to define a very simple interface which provides us with a speed property:

    \quotefromfile interfaceframework/qface-tutorial/ch1-basics/instrument-cluster.qface
    \printuntil }

    First, we need to define which module we want to describe. The module acts as a namespace,
    because the IDL file can contain multiple interfaces.

    \quotefromfile interfaceframework/qface-tutorial/ch1-basics/instrument-cluster.qface
    \printuntil module

    The most important part of the module is its interface definition.

    \quotefromfile interfaceframework/qface-tutorial/ch1-basics/instrument-cluster.qface
    \skipto interface
    \printuntil }

    In this case, we define an interface named \c InstrumentCluster that consists of one property.
    Each property definition must contain at least a type and a name. Most of the basic types are
    built-in and can be found in the \l{QFace IDL Syntax}.

    \section2 Auto-generation

    Now that our first version of the IDL file is ready, it's time to auto-generate an API from it,
    using the \l{Qt Interface Framework Generator}{Interface Framework Generator tool}. Similar to
    \l{Using the Meta-Object Compiler (moc)}{moc}, this auto-generation process is integrated into the
    build system and is done at compile time.

    In the following snippets we build a C++ library based on our IDL file:

    \e CMake:

    \quotefromfile interfaceframework/qface-tutorial/ch1-basics/frontend/CMakeLists.txt
    \skipto find_package
    \printto install

    First \e find_package needs to be used to get all needed libraries into the CMake build system.
    A new library is defined with \l {qt_add_library} and, using CMake target_properties, the
    output name, as well as the output directory are set. As we need to link to this library in the
    future, it is easier to put the file into the upper directory.

    By calling the \l {qt_ifcodegen_extend_target} function, the \c autogenerator is called and the
    previously defined library is extended with the generated files. The input file is specified
    using the \e IDL_FILES argument. See \l{Build System Integration} for more information.

    \e qmake:

    \quotefromfile interfaceframework/qface-tutorial/ch1-basics/frontend/frontend.pro
    \printto CONFIG += install_ok

    Most of the \c{.pro} file is a standard setup to define a C++ library, using "lib" \c TEMPLATE
    and defining the required file name in the \c TARGET variable. The \c qtLibraryTarget function
    that we use helps to append the "d" postfix on the filename correctly, for a library that
    provides debugging information. In the future, we need to link this file, so we set the
    \c DESTDIR to the upper directory to simplify this.

    \note Windows searches for libraries in the same directory automatically.

    Activating the Interface Framework Generator integration requires the \c CONFIG variable to specify the
    \c ifcodegen option. This makes sure the Interface Framework Generator is called during the build process,
    using the QFace file that we specify in \c IFCODEGEN_SOURCES. For more information, see
    \l{Build System Integration}.

    \section2 Which Files are Auto-generated

    The Interface Framework Generator works based on generation templates. These templates define what content
    should be generated from a QFace file. Using qmake, the template needs to be defined by the
    \c IFCODEGEN_TEMPLATE variable. If it is not defined, it defaults to the "frontend" template.
    In CMake the template needs to be specified using the \c TEMPLATE argument of
    \l {qt_ifcodegen_extend_target} and friends.
    For more details on these templates, see \l{Use the Generator}.

    In short, the "frontend" template generates:
    \list
        \li a C++ class derived from QIfAbstractFeature for every interface in the QFace file
        \li one module class that helps to register all interfaces to QML and stores global types
            and functions.
    \endlist

    To inspect the C++ code yourself, you can view these files in the library's build folder.

    Right now, the most important auto-generated file for us, is the resulting C++ class for our
    defined interface. It looks like this:

    \quotefile interfaceframework/qface-tutorial/ch1-basics/frontend/frontend/instrumentcluster.h

    As you can see, the auto-generated C++ class implements a \c speed property, that we previously
    defined in the QFace file. By using the \c Q_OBJECT and \c Q_PROPERTY macros, the class is now
    ready for use directly in your QML code.

    \section2 Integrate the Front End Library with the QML Code

    For this integration, we use the auto-generated front-end library from the QML code. For the sake
    of simplicity, we follow the standard Qt example pattern and use a small C++ main function
    which registers our auto-generated types to QML and loads the Instrument Cluster QML code into
    the QQmlApplicationEngine:

    \quotefromfile interfaceframework/qface-tutorial/ch1-basics/instrument-cluster/main.cpp
    \skipto #include "instrumentclustermodule.h"
    \printuntil }

    All we need now is the actual integration of the InstrumentCluster QML element and connecting
    the \c speed property to the \c leftDial. This is done by instantiating the element first with
    the \c instrumentCluster ID.

    \quotefromfile interfaceframework/qface-tutorial/ch1-basics/instrument-cluster/Cluster.qml
    \skipto import
    \printuntil InstrumentCluster
    \printuntil }
    \codeline

    Lastly, we can create a Binding for the \c LeftDial Item's \c value property to our
    InstrumentCluster API's \c speed property.

    \printuntil }

    \target chapter2
    \section1 Chapter 2: Extend the Interface and add Annotations

    In this chapter we extend our Middleware API with more properties via enums and by defining our
    own structure.

    \section2 Define Speed as a Read-only Property

    \l{define-speed-property}{Previously}, we defined the speed property in our QFace file in the
    following way:

    \quotefromfile interfaceframework/qface-tutorial/ch1-basics/instrument-cluster.qface
    \printuntil }

    This property is defined as readable and writable, as we didn't use any extra specifiers.
    However, it's not necessary for our Instrument Cluster example to have a writable \c speed
    property because it's not used to accelerate the car, but just to visualize the current state.

    To define the property as read-only, use the \c readonly keyword.

    \quotefromfile interfaceframework/qface-tutorial/ch2-enums-structs/instrument-cluster.qface
    \printuntil readonly
    \skipto }
    \printuntil }

    When we build our app again, the build system recognizes this change and runs the Interface Framework
    Generator to generate an updated version of the C++ code. After the Interface Framework Generator is done,
    open the \c instrumentcluster.h from the build folder and notice that the generated
    \c speed property changed -- it no longer has a setter anymore and is now read-only.

    \quotefromfile interfaceframework/qface-tutorial/ch2-enums-structs/frontend/frontend/instrumentcluster.h
    \skipto class Q_EXAMPLE
    \printuntil Q_PROPERTY
    \dots
    \skipto };
    \printuntil };

    \section2 Extend the Interface

    To reach our goal to provide a full simulation for the Instrument Cluster, we need to add more
    properties to our QFace file: \c rpm, \c fuel and \c temperature:

    \quotefromfile interfaceframework/qface-tutorial/ch2-enums-structs/instrument-cluster.qface
    \printuntil readonly real temperature
    \skipto }
    \printuntil }

    You might have noticed that we use a different type for the \c fuel and \c temperature
    properties. We use \c real here, as we would like to show the temperature as a floating point
    number, and the current fuel level as a value between 0 and 1.

    \section2 Define a New Enum Type

    One useful feature is to be able to switch between the metric and the imperial system, so we
    need to define a property for the system we currently use. Using a boolean property would work,
    but doesn't offer a nice API, so we define a new enum type in the QFace file and use it as the
    type for our new \c system property:

    \quotefromfile interfaceframework/qface-tutorial/ch2-enums-structs/instrument-cluster.qface
    \printuntil readonly SystemType
    \skipto }
    \printuntil enum
    \printuntil }

    In the auto-generated code, this results in an enum which is part of the module class, making it
    possible for the same enum to be used by multiple classes which are part of the same module:

    \quotefile interfaceframework/qface-tutorial/ch2-enums-structs/frontend/frontend/instrumentclustermodule.h

    \section2 Add a New Structure

    To display warnings on the Instrument Cluster's right dial, we'd like to use a structure that
    stores color, icon, and text for the warning; instead of using 3 independent properties.
    Similar to defining an interface, we can use the \c struct keyword in our QFace file:

    \quotefromfile interfaceframework/qface-tutorial/ch2-enums-structs/instrument-cluster.qface
    \skipto struct
    \printuntil }

    Using this new structure as a type for a property, works in the same way as when using an enum.
    The QFace file should now look like this:

    \quotefile interfaceframework/qface-tutorial/ch2-enums-structs/instrument-cluster.qface

    \section2 Integrate the New Properties

    Like in the previous chapter, actually integrating the newly introduced properties involves
    creating Bindings. The \c rpm property can be directly connected to the \c rightDial Item's
    \c value property; the same is done for the top Item's \c temperature property. To control
    which unit is displayed in the left Dial, the \c leftDial Item provides \c metricSystem, a bool
    property. As we used an enum in our QFace file, we need to convert the value first by testing
    the \c sytemType property for the "Metric" value.

    \quotefromfile interfaceframework/qface-tutorial/ch2-enums-structs/instrument-cluster/Cluster.qml
    \skipto LeftDial
    \printuntil }
    \codeline

    These enums are part of the module class, which is also exported to QML as
    \c InstrumentClusterModule. To trigger a warning in the \c rightDial Item, we use 3 bindings to
    connect to the 3 member variables in the structure:

    \printuntil }

    \target chapter3
    \section1 Chapter 3: Add a Simulation Back End and Annotations with a QML plugin

    In the previous two chapters, we wrote a Middleware API using a QFace file and used the Interface Framework
    Generator to auto-generate a C++ API in the form of a library. Now, in this chapter, we extend
    this further by introducing a simulation back end and using annotations to define default values
    for our simulation.

    \section2 Separation between the Front End and Back End

    Both QtInterfaceFramework and the Interface Framework Generator enable you to write code that separates the front end from the
    back end. This allows you to split an API from its actual implementation. Already, Qt uses this concept in a
    lot of areas, most prominently in the underlying window system technology on various Qt
    platforms like XCB on Linux and Cocoa on macOS.

    The same separation is done for our Middleware API, where the front end provides the API as
    a library; the back end provides an implementation of this API. This implementation is based on
    QtInterfaceFramework's \l{Dynamic Backend System} which enables us to switch between such back ends at runtime.

    \image feature-backend.png

    \section2 Add a Simulation Back End

    For our Instrument Cluster, we'd like to add such a back end to provide actual values. For now,
    we'd like to just have some simulation behavior as we can't connect it easily to a real car.
    This is why such back ends are called "simulation backend". To add this type of back end, once
    again, we use the Interface Framework Generator to do the heavy lifting for us and generate one. This work
    is done in a similar way to when we generated a library with the "frontend" template. But now,
    we are using the "backend_simulator" template:

    \e CMake:

    \quotefromfile interfaceframework/qface-tutorial/ch3-simulation-backend/backend_simulator/CMakeLists.txt
    \skipto find_package
    \printto target_link_libraries

    Similar to the front-end library, first the used components are imported using \e find_package.
    As we want to build a plugin (dynamic library) which is loaded at runtime instead of linking
    against it, we use the \l {qt_add_plugin} function instead. One important aspect
    here is that the library name ends with "_simulation", which is a way to tell QtInterfaceFramework that this
    is a simulation back end. When a "production" back end is available, it is preferred over the
    "simulation" one. For more information, see \l{Dynamic Backend System}.

    As before, the Interface Framework Generator is called by using the \l{qt_ifcodegen_extend_target}
    function, this time setting "backend_simulator" as the \c TEMPLATE.

    \e qmake:

    \quotefromfile interfaceframework/qface-tutorial/ch3-simulation-backend/backend_simulator/backend_simulator.pro
    \printto DESTDIR
    \skipto QT
    \printuntil CONFIG
    \skipto IFCODEGEN_TEMPLATE
    \printto CONFIG += install_ok

    Just like for the front-end library, the project file builds a \c lib and defines the library
    name using \c qtLibraryTarget to also support the Windows debug postfix. One important aspect
    here is that the library name ends with "_simulation", which is a way to tell QtInterfaceFramework that this
    is a simulation back end. When a "production" back end is available, it is preferred over the
    "simulation" one. For more information, see \l{Dynamic Backend System}.

    Enabling the Interface Framework Generator is also done in the same way as we did earlier: by using the same
    \c IFCODEGEN_SOURCE variable, but defining \c IFCODEGEN_TEMPLATE to "backend_simulator", to use the
    correct generation template. In addition, we need to add 'plugin' to the \c CONFIG variable,
    to make this library a Qt plugin which can be easily loaded at runtime.

    \section2 Link Settings and Locating Plugins

    Trying to build the project file just as it is, right now, would result in compilation and
    linking errors. This is because: to do the front end and back-end separation, we need to have the
    back end implement a defined interface class, that is known to the front end. This interface is
    aptly called "backend interface" and is automatically generated as part of the front-end
    library. Because this class provides signals and slots and uses QObject for its base class, you
    need to link to the front-end library when you inherit from it. As this is needed for the
    back-end plugin, we need to add the following lines in addition:

    \e CMake:

    \quotefromfile interfaceframework/qface-tutorial/ch3-simulation-backend/backend_simulator/CMakeLists.txt
    \skipto target_link_libraries
    \printto install

    By defining the front-end library named \e libIc_ch3 as a target link library the include
    path gets updated accordingly.

    \e qmake:

    \quotefromfile interfaceframework/qface-tutorial/ch3-simulation-backend/backend_simulator/backend_simulator.pro
    \skipuntil CONFIG
    \printuntil INCLUDEPATH

    Now the project should build fine and create the plugin in your build folder; or the plugin
    folder if you don't use a shadow build. When you start the Instrument Cluster again, you should
    see the following message:

    \badcode
    There is no production backend implementing "Example.If.InstrumentCluster.InstrumentCluster" .
    There is no simulation backend implementing "Example.If.InstrumentCluster.InstrumentCluster" .
    No suitable ServiceObject found.
    \endcode

    This message indicates that QtInterfaceFramework is still unable to find the simulation plugin we just created.
    Here, you need to know a little bit more about Qt's Plugin System, especially how it it finds
    plugins.

    Qt searches for it's plugins in multiple directories, the first one is the plugin folder,
    \c plugins, which comes with your Qt installation. Within the plugins folder, every plugin type
    has it's own sub-folder, such as \c platforms, for the platform plugins used to talk to the
    underlying platform API and the windowing system.

    Similarly, QtInterfaceFramework searches for its back-end plugins in the \c interfaceframework folder.

    To make sure our simulation back end ends up in such a folder, we add the following changes in
    our build system file:

    \e CMake:

    \quotefromfile interfaceframework/qface-tutorial/ch3-simulation-backend/backend_simulator/CMakeLists.txt
    \skipuntil qt_add_plugin
    \printuntil set_target_properties

    \e qmake:

    \quotefromfile interfaceframework/qface-tutorial/ch3-simulation-backend/backend_simulator/backend_simulator.pro
    \skipto DESTDIR
    \printuntil DESTDIR

    You might wonder how creating an \c interfaceframework folder in the upper directory solves the problem of
    finding the plugin as it's not part of the system plugins folder. But Qt supports searching in
    multiple folders for such plugins and one of those folders is the path to where the executable
    itself is located.

    Alternatively, we could add an additional plugin path using the QCoreApplication::addLibraryPath()
    function or using the \c QT_PLUGIN_PATH environment variable. For more information, see
    \l{https://doc.qt.io/qt-5/plugins-howto.html}{How to create Qt Plugins}.

    Now everything is in place, but because our plugin links against the front-end library, we need
    to make sure the library can be found by the dynamic linker. This can be achieved by
    setting the \c LD_LIBRARY_PATH environment variable to our library folder. But this results
    in the problem, that every user would need to set this variable to be able to use our
    application.

    \e CMake:

    Using CMake, the location of our front-end library is automatically added as a \e RUNPATH to the
    the binary and no further steps are needed.

    \e qmake:

    In qmake we can ease the setup by using a relative \e RPATH instead of the \c LD_LIBRARY_PATH
    and annotate our plugin with the information for the linker, where it might find the needed
    libraries, relative to the plugin's location:

    \quotefromfile interfaceframework/qface-tutorial/ch3-simulation-backend/backend_simulator/backend_simulator.pro
    \skipto INCLUDEPATH
    \printuntil QMAKE_RPATHDIR

    \section2 Export the QML Types in a QML Plugin

    In the first chapter, we extended our \c main.cpp to register all types of our auto-generated
    Middleware APIs. Although this works fine, in bigger projects it's common to use a QML Plugin
    instead and be able to use the \c qml executable for development. Although the code for doing this is
    not complex, the Interface Framework Generator supports this as well and makes it even easier.

    From the first chapter, we know that the module name is used for the QML import URI. This is
    important for a QML plugin as the QmlEngine expects the plugin in a specific folder to
    follow the module name, where every section of the module name is a sub-folder. Our build system
    file to generate a QML plugin looks like this:

    \e CMake:

    \quotefromfile interfaceframework/qface-tutorial/ch3-simulation-backend/imports/CMakeLists.txt
    \skipto qt_ifcodegen_import_variables
    \printto install

    Unlike all our previous generator calls we don't extend a previously defined target, but
    import the generated code into CMake and pass it to the \l {qt_add_qml_module} function.
    The \l {qt_ifcodegen_import_variables} function will call the generator and export variables
    starting with \e CLUSTER as prefix to the current CMake scope.
    Those variables reference auto-generated code, but also expose other information like the QML
    import URI.
    In the next call, the variables are used to define a QML Module with the correct URI and version
    (as specified in our IDL file). By using the \e OUTPUT_DIRECTORY variable we can make sure that
    the correct folder structure is generated and we can import the QML plugin directly from within
    the build folder.

    \note Instead of generating a QML plugin, the new QML type registration can be used, which was
    introduced in \b 6.3. In order to use this new mechanism the frontend CMakeLists.txt has to be
    extended like this:

    \badcode
    qt_ifcodegen_extend_target(libIc_ch3
        IDL_FILES ../instrument-cluster.qface
        PREFIX CLUSTER
        TEMPLATE frontend
    )
    qt_add_qml_module(libIc_ch3
        OUTPUT_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/../imports/${CLUSTER_URI_PATH}"
        URI ${CLUSTER_URI}
        VERSION ${CLUSTER_VERSION}
        RESOURCE_PREFIX "/"
        IMPORTS QtInterfaceFramework/auto
    )
    \endcode

    Please see \l {QML Type Registration} for more information.

    \e qmake:

    \quotefromfile interfaceframework/qface-tutorial/ch3-simulation-backend/imports/imports.pro
    \printto target.path

    All lines until \c IFCODEGEN_SOURCES should be familiar. We use \c CONFIG to build a plugin, then
    define the settings for the linker to link against our front-end library. Then, we use
    \c IFCODEGEN_TEMPLATE to define "qmlplugin" as the generation template. Instead of adding
    \c ifcodegen to \c CONFIG, this time we use
    \l{https://doc.qt.io/qt-5/qmake-test-function-reference.html#load-feature}
    {qmake's load() function} to explicitly load the feature. This enables us to use the \c URI
    variable which is part of the "qmlplugin" generation template. This URI can be used to define
    a \c DESTDIR by replacing all dots with slashes.

    In addition to the folder structure, the QmlEngine also needs a \c qmldir file which indicates
    what files are part of the plugin, and under which URI. For more information, see
    \l{https://doc.qt.io/qt-5/qtqml-modules-qmldir.html}{Module Definition qmldir Files}. Both this
    \c qmldir file and a \c plugins.qmltypes file which provides information about code-completion,
    are auto-generated by the Interface Framework Generator; but they need to be placed next to the library. To do
    so, we add the files to a scope similar to an \c INSTALL target, but add it to the \c COPIES
    variable instead. This makes sure that the files are copied when the plugin is built.

    Now the plugin is ready for use, but our Instrument Cluster application doesn't know where to
    search for it and is still using the old hard-coded registration. So, we can now remove the
    linking step in the \c instrument-cluster build system file and change our main file
    accordingly:

    \quotefromfile interfaceframework/qface-tutorial/ch3-simulation-backend/instrument-cluster/main.cpp
    \skipto #include
    \printuntil }

    What has changed is that we've now added an additional import path with the \c addImportPath
    function, which points to the "imports" folder next to the binary's location.

    \target chapter4
    \section1 Chapter 4: Add a Custom Simulation

    So far, we've created a Middleware API and integrated it into our Instrument Cluster QML code,
    extended it with a QML plugin, and generated a simulation back end. In the background, quite a
    lot has happened to support us; but on the UI side not much has changed till now. This chapter
    is about bringing our simulation back end to life by defining sane default values and starting
    to simulate a real car ride.

    \section2 Define Default Values

    We start by defining default values for our properties, using annotations in our QFace file.
    An annotation is a special kind of comment which adds extra data to an interface, method,
    property, and so on. For this use case we use the \c config_simulator annotation. For more
    information, see \l{annotations_reference}{Annotations}. A reference of all supported annotations
    can be found \l{annotations-yaml}{here}.

    Currently, in our Instrument Cluster, the temperature defaults to 0. Let's change this to a
    temperature in spring, 15 degrees Celsius, with the following YAML fragment, which needs to be
    added above the property definition in the qface file.

    \quotefromfile interfaceframework/qface-tutorial/ch4-simulation-behavior/instrument-cluster.qface
    \skipuntil interface
    \printuntil temperature

    Compile the plugin again for this temperature change to be reflected in our Instrument Cluster.
    Let's see how this actually works: when starting the Interface Framework Generator, the config_simulator
    annotation was transformed into a JSON file that's now part of the "simulation backend" build
    folder. This JSON file looks like this:

    \quotefile interfaceframework/qface-tutorial/ch4-simulation-behavior/backend_simulator/backend_simulator/instrumentclustermodule_simulation_data.json

    But how is this JSON file related to the actual simulation back-end code? The auto-generated
    simulation back-end code uses QIfSimulationEngine, that reads the JSON file and provides its
    data to a QML simulation file. A default QML file is also auto-generated and loaded from the
    QIfSimulationEngine. This default QML file provides the behavior of what should happen in the
    the simulation back end.

    Later, in the next section, we take a look at the QML file and how we can change it. But first,
    let's see how we can change the default values in a more dynamic way.

    The QIfSimulationEngine allows us to override which JSON file should be loaded into the
    engine, when we set the \c QTIF_SIMULATION_DATA_OVERRIDE environment variable. Since there can
    be multiple engines run by different back ends, we need to define which engine we're referring
    to. In the auto-generated code, the module name is always used as the engine specifier. For this
    chapter, we already prepared a second JSON file which is part of our source directory. Setting
    the environment variable as follows, changes the \c systemType to km/h instead of mph:

    \badcode
    QTIF_SIMULATION_DATA_OVERRIDE=example.if.instrumentclustermodule=<path-to-file>/kmh.json
    \endcode

    \section2 Define a QML Behavior

    Before we define our custom behavior, let's see what's been auto-generated for us. There are two
    QML files: The first is \c instrumentcluster_simulation.qml and rather simple. It defines an
    entry point that instantiates the second file, an \c InstrumentClusterSimulation.qml file. This
    split is done as there can be multiple interfaces defined as part of the same module.

    \note A QML Engine can only have one entry point. While QIfSimulationEngine has this same
    limitation, if you have a module with multiple interfaces, you want to have multiple simulation
    files -- one per interface. This is why the first QML file merely instantiates the QML files for
    all interfaces that it supports. In the case of our example, it's only one interface.

    The InstrumentClusterSimulation.qml file is very interesting:

    \quotefile interfaceframework/qface-tutorial/ch4-simulation-behavior/backend_simulator/backend_simulator/InstrumentClusterSimulation.qml

    First, there's a \c settings property, that's initialized with the return value from the
    \l{IfSimulator::findData}{IfSimulator.findData} method, which takes the
    \l{IfSimulator::simulationData}{IfSimulator.simulationData} and a string as input. The
    \c simulationData is the JSON file represented as a JavaScript object.

    The \c findData method helps us to extract only the data that is of interest for this
    interface, \c InstrumentCluster. The properties that follow help the interface to know whether
    the default values are set. The \c LoggingCategory is used to identify the log output from this
    simulation file.

    Afterwards, the actual behavior is defined by instantiating an \c InstrumentClusterBackend Item
    and extending it with more functions. The \c InstrumentClusterBackend is the interface towards
    our \c InstrumentCluster QML front end class. But, apart from the front end, these properties are
    also writable to make it possible to change them to provide a useful simulation.

    Each time a front-end instance connects to a back end, the \c initialize() function is called.
    The same applies to the QML simulation: as the \c initialize() C++ function forwards this to
    the QML instance. This also applies to all other functions, like setters and getters, for
    properties or methods. For more details, see \l{QIfSimulationEngine}.

    Inside the QML \c initialize() function, we call \c{IfSimulator.initializeDefault()}, to read
    the default values from the \c simulationData object and initialize all properties. This is
    done only \b once, as we don't want the properties be reset to default when the next front-end
    instance connects to the back end. Lastly, the base implementation is called to make sure that
    the \c initializationDone signal is sent to the front end.

    Similarly, a setter function is defined for each property; they use the
    \c{IfSimulator.checkSettings()} to read specific constraint settings for the property from
    the \c simulationData and check whether these constraints are valid for the new value. If
    these constraints aren't valid, then \c{IfSimulator.constraint()} is used to provide a
    meaningful error message to the user.

    \section2 Define Our Own QML Simulation

    As mentioned above, the \c InstrumentClusterBackend item provides all the properties of our
    QFace file. This can be used to simulate a behavior by changing the properties to the values
    we want. The simplest form for this would be value assignment, but this would be rather static
    not exactly what we'd like to achieve. Instead, we use QML Animation objects to change the
    values over time:

    \quotefromfile interfaceframework/qface-tutorial/ch4-simulation-behavior/backend_simulator/simulation.qml
    \skipto NumberAnimation
    \printuntil }

    The code snippet above changes the speed property to 80 over 4000 seconds and simulates an
    accelerating car. Extending this to the other properties, and combining both sequential and
    parallel animations, we can create a full simulation:

    \quotefromfile interfaceframework/qface-tutorial/ch4-simulation-behavior/backend_simulator/simulation.qml
    \skipto property var animation
    \printuntil property: "fuel"
    \printuntil property: "fuel"
    \printuntil }
    \printuntil }

    Then, to provide a nice simulation for the \c rpm property, we use a binding which does some
    calculations based on the current speed. The complete simulation file looks like this:

    \quotefromfile interfaceframework/qface-tutorial/ch4-simulation-behavior/backend_simulator/simulation.qml
    \skipto import
    \printuntil /^\}/

    The next step is to tell the Interface Framework Generator and the QIfSimulationEngine about our new
    simulation file. Similar to QML files, the best approach here is to put the simulation file into
    a resource file. In our example, we add a new file called \c simulation.qrc which contains our
    \c simulation.qml using the \c{/} prefix.

    In our QFace file, this location now needs to be added in the form of an annotation:

    \quotefromfile interfaceframework/qface-tutorial/ch4-simulation-behavior/instrument-cluster.qface
    \printuntil module
    \dots

    Now, rebuilding the simulation back end embeds the simulation file into the plugin and hands the
    file over to the QIfSimulationEngine, which starts the simulation when loaded.

    \target chapter5
    \section1 Chapter 5: Add a Simulation Server Combined with QtRemoteObjects

    In this chapter we extend our instrument cluster to use an Inter-Process Communication (IPC)
    mechanism and use two processes. At the moment, the simulation is loaded as a plugin that
    causes it to be part of the same service. Although this is good enough for a small example
    application, it's not how it's done in modern multi-process architectures, where multiple
    processes need to be able to access the same value and react to changes. We could write a
    second Application that uses the same Middleware API. However, we can achieve the same thing
    just by starting the Instrument Cluster twice and checking whether the animations are in sync.
    Currently, they're not.

    \image qface-tutorial-unsync.gif

    \section2 Add a QtRemoteObjects Integration

    The IPC for this example is QtRemoteObjects, because the Interface Framework Generator already supports it
    out of the box. To use QtRemoteObjects we generate a second plugin, a "production" back end,
    this time. Production back ends are automatically preferred over the simulation back end we
    introduced before.

    This is done with the following build system files:

    \e CMake:

    \quotefromfile interfaceframework/qface-tutorial/ch5-ipc/backend_qtro/CMakeLists.txt
    \skipto qt_add_plugin
    \printto install

    \e qmake:

    \quotefromfile interfaceframework/qface-tutorial/ch5-ipc/backend_qtro/backend_qtro.pro
    \printto CONFIG += install_ok

    These files are almost identical to the ones we used earlier for our simulation back end.
    For now we highlight what's changed.

    The name of the plugin doesn't end with "_simulation" to indicate that this is a "production"
    back end. The template is now changed to "backend_qtro" to generate a back end that uses
    \l{Qt Remote Objects Replica}{Qt Remote Objects Replicas} to connect to a \l{Qt Remote Objects Source}
    that provides the values. In addition to a back end based on QtRemoteObject, we also need a
    server based on QtRemoteObject . This part can also be auto-generated using the Interface
    Framework Generator in a similar fashion:

    \e CMake:

    \quotefromfile interfaceframework/qface-tutorial/ch5-ipc/simulation_server/CMakeLists.txt
    \skipto qt_add_executable
    \printto # Resources:

    \e qmake:

    \quotefromfile interfaceframework/qface-tutorial/ch5-ipc/simulation_server/simulation_server.pro
    \printto RESOURCES

    Because we'd like to generate a server binary, the qmake \c TEMPLATE needs to be set to "app"
    instead of "lib", in CMake we use \l {qt_add_executable} instead. Similar to the plugin, the
    server also needs to link against our library to give it access to the defined enums,
    structures, and other types. The template we use to generate a simulation server is called
    "server_qtro_simulator".

    \section2 Reuse the Existing Simulation Behavior

    Now, if you start the server and then the Instrument Cluster, you don't see the simulation
    from our previous chapter anymore. The reason for this, is that the simulation code is part of
    our simulation back end, but this back end is no longer used as we added the
    QtRemoteObjects-based "production" back end.

    Because we used the "server_qtro_simulator" generation template, this can easily be fixed, as
    the generated server code is also using the QIfSimulationEngine and supports to use the same
    simulation file than our simulation back end. We just need to extend the project file in the
    same way as we did before and are also able to use the same resource file for this.

    \e CMake:

    \quotefromfile interfaceframework/qface-tutorial/ch5-ipc/simulation_server/CMakeLists.txt
    \skipto # Resources:
    \printto install

    \e qmake:

    \quotefromfile interfaceframework/qface-tutorial/ch5-ipc/simulation_server/simulation_server.pro
    \skipto RESOURCES
    \printuntil RESOURCES

    In the same way, we can also use the other simulation data JSON file that we defined in the
    previous chapter, by using the same environment variable. We just need to pass it to the
    server instead of our Instrument Cluster application.

    Let's do the final test: starting two Instrument Cluster instances should now show the
    animations in sync:

    \image qface-tutorial-sync.gif

    \target chapter6
    \section1 Chapter 6: Develop a Production Back End with D-Bus

    Previously, we extended our Instrument Cluster code by using QtRemoteObjects as IPC and
    auto-generated a back end for it, as well as a server that provides the simulation. In this
    chapter, we'd like to write our own back end \b manually using D-Bus as IPC.

    We've already prepared a working D-Bus server which provides limited simulation.

    First, let's look at the server code and see what's done there; then write the backend that
    connects to it.

    \section2 D-Bus Server

    As mentioned above, we use D-Bus for this chapter and we already have an XML file that
    describes the D-Bus interface, similar to our QFace file:

    \quotefile interfaceframework/qface-tutorial/ch6-own-backend/demo_server/instrumentcluster.xml

    This XML file is used to let qmake generate a base class which is extended by the server with
    actual functionality. For more information, see \l{QtDBus}.

    Our D-Bus server starts on the session bus, on the \c{/} path, and provides an interface named
    "Example.If.InstrumentCluster". To simulate some values, we keep it simple and use a timer
    event to change the speed value every 100 milliseconds. Then, we start from 0, once the
    maximum of 250 is reached. Similarly, the \c rpm value is increased to 5000. For all other
    properties, we provide hard-coded values.

    \quotefromfile interfaceframework/qface-tutorial/ch6-own-backend/demo_server/instrumentcluster.cpp
    \skipto timerEvent
    \printuntil }

    \section2 Write Our own D-Bus Back End

    Let's start with a build system file for our back end. This is very similar to previous
    files, but it doesn't use the Interface Framework Generator. Instead, it uses \c DBUS_INTERFACES
    for qmake to auto-generate some client code which sends and receives messages over D-Bus.
    In the CMake case the \l {qt_add_dbus_interface} function is used to do the same.

    Now, we need to define an entry point for our plugin. This plugin class needs to derive from
    QIfServiceInterface and implement two functions:

    \list
        \li \c {QStringList interfaces()} -- that returns a list of all interfaces this plugin
            supports.
        \li \c {QIfFeatureInterface *interfaceInstance(const QString &interface)} -- that returns
            an instance of the requested interface.
    \endlist

    Additionally, we also need to provide a list of interfaces we support as plugin metadata, in
    the form of a JSON file which looks like this:

    \quotefile interfaceframework/qface-tutorial/ch6-own-backend/backend_dbus/instrumentcluster_dbus.json

    We need this list, as it gives QtInterfaceFramework the chance to know which interfaces a back end supports,
    before instantiating it and loading only the plugins which the application code needs.

    Our plugin code looks like this:

    \quotefromfile interfaceframework/qface-tutorial/ch6-own-backend/backend_dbus/instrumentclusterplugin.cpp
    \skipto #include
    \printto

    In \c interfaces() we use the IID which is defined in \c{instrumentclusterbackendinterface.h}
    from our auto-generated library. In \c interfaceInstance() we check for the correct string and
    return an instance of the instrument cluster back-end we implemented.

    This back end is defined in \c instrumentclusterbackend.h and derives from
    \c InstrumentClusterBackendInterface. In our \c InstrumentClusterBackend class, we need to
    implement all pure virtual functions from InstrumentClusterBackendInterface and derived classes.

    For our example, this isn't complex, as we just need to implement the initialize() function.
    If our XML file would use writable properties or methods, then we'd need to implement those as
    well. We don't need to implement getters for our properties, because QtInterfaceFramework uses the changed
    signals during the initialization phase to get information about the current state. Although
    the generated D-Bus interface class would provide getters to retrieve the properties from our
    server, it's not recommended to use these when you develop a back-end. These getters are
    implemented by using synchronous calls, which means they will block the event loop until an
    answer is received by the client. Since this can lead to performance issues, we recommend to
    use \b asynchronous calls instead.

    In our back end, we define a fetch function for each property that's implemented like this:

    \quotefromfile interfaceframework/qface-tutorial/ch6-own-backend/backend_dbus/instrumentclusterbackend.cpp
    \skipto ::fetchSpeed
    \printto ::fetchRpm

    First, we add the property to a list, to know which properties have been fetched successfully.
    Next, we use the \c asyncCall() function to call the getter for the \c speed property and use a
    \c QDBusPendingCallWatcher to wait for the result. Once the result is ready, the lambda removes
    the property again from our \c fetchList, uses the \c onSpeedChanged() function to store the
    value and notifies the front end about it. Since we don't need the watcher anymore, we delete it
    in the next event loop run using \c deleteLater(), and call the \c checkInitDone() function.

    The \c checkInitDone() function is defined as follows:

    \quotefromfile interfaceframework/qface-tutorial/ch6-own-backend/backend_dbus/instrumentclusterbackend.cpp
    \skipto ::checkInitDone
    \printto onSpeedChanged

    It ensures that the \c initializationDone() signal is sent to the front end once all our
    properties are fetched from the server, and the initialization is complete.

    In addition to retrieving the current state from the server, we also need to inform our front end
    every time a property changes. This is done by emitting the corresponding change signal when the
    server changes one of its properties. To handle this, we define a slot for each property. This
    slot saves the property in our class an emits the change signal:

    \quotefromfile interfaceframework/qface-tutorial/ch6-own-backend/backend_dbus/instrumentclusterbackend.cpp
    \skipto void InstrumentClusterBackend::onSpeedChanged(int speed)
    \printto onRpmChanged

    The same slot is also used during the initialization phase to save and emit the value.

    You might wonder why saving the value is needed at all, if we can just emit the signal. This is
    because the back-end plugin is used directly by every instance of the \c InstrumentCluster class
    and every instance calls the \c initialize() function to retrieve the current state. Instead of
    fetching all properties again, the second \c initialize() call just emits values that were
    already saved; and the slots keep them up to date.

    Now, when we start the Instrument Cluster, our back end should connect to our D-Bus server and
    look like this:

    \image qface-tutorial-dbus.gif

    \target chapter7
    \section1 Chapter 7: Write a Template for a Back End with D-Bus

    Now as we have our own production backend ready, it's a good time to move it into an ifcodegen
    template. For a simple example like this, keeping the handwritten backend would be totally fine,
    but once you have defined multiple Modules and Interfaces it is a lot of boiler-plate code to
    maintain.

    \section2 Create a template from scratch

    The best way to start a new template, is to copy the existing code to a new folder for our
    template. First we create a \c templates folder and within that a folder called \c backend_dbus.
    This follows the template naming convention from ifcodegen, but you can also use any other
    name as well.

    The next step is to rename the files in our template folder, to make them more generic and
    identify them as templates by adding an additional \c tpl suffix.

    The template folder should now look like this:

    \list
        \li backend.cpp.tpl
        \li backend.h.tpl
        \li plugin.cpp.tpl
        \li plugin.h.tpl
        \li plugin.json.tpl
    \endlist

    \section2 Convert all files to templates

    Let's go over all the files in the template and use the special \l {Jinja Template Syntax} to
    extend them for our needs.

    \section3 plugin.h.tpl

    The first thing we usually want to do is to add a special comment for the autogenerated file.
    This will mark it as autogenerated and that it shouldn't be edited manually.

    The following line includes a predefined comment file (part of ifcodegen):

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus/plugin.h.tpl
    \skipto {% include
    \printuntil {% include

    \note The \c.cpp suffix of the included file indicates that the comments are intended to be used
    in C++ files.

    Next we want to replace the hardcoded \c #ifdef names with something derived from the module name.
    This is done by defining some helper variables first.
    The first variable is named \c class and uses a format string which consists of the name of the
    module and the static text \c DBusPlugin.

    Given that our module is named \c Example.If.InstrumentClusterModule the resulting string will be
    \c InstrumentClusterModuleDBusPlugin.

    The second variable also uses a format string but uses the previously defined class variable
    followed by a pipe symbol. The pipe indicates that the variable should be given to a function that
    proccess the variable as input to create some new output. This is called a \l {Filter
    Reference}{filter} in Jinja. The filter is called \c upper and will make the given module name
    all upper-case.

    The next step is to use the new defined variables to replace the hardcoded defines. In order
    to use a variable and print its content to the autogenerated code, double curly braces have to
    be used. All text that does not use the Jinja syntax is printed as is. With that in mind we
    can keep the include statements as they are and the template file should look like this:

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus/plugin.h.tpl
    \skipto #ifndef
    \printuntil #define
    \dots
    \skipto #endif
    \printto

    In the same way we continue to replace all occurrences of the hardcoded class name with \c {{class}}
    and replace the hardcoded plugin metadata json with \c {{module.module_name|lower}}.json.

    The class declaration will now look like this:

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus/plugin.h.tpl
    \skipto class {{class}}
    \printuntil };

    You might have noticed that instead of using a hardcoded pointer to the \c InstrumentClusterBackend
    we now use \c QVector<QIfFeatureInterface *>. This is needed as a module can have multiple
    interfaces and the plugin needs to store instances for all of them. This can be easily achieved
    by using a vector instead of hardcoded values.

    \section3 plugin.cpp.tpl

    In a similar fashion the \c plugin.cpp.tpl can be extended with \l {Jinja Template Syntax}
    {Jinja syntax}. It also starts by including the generated comment and by defining the \c class
    variable. In addition to including the autogenerated plugin header, we also need to include the
    header for all backend classes. As mentioned before, a module can have multiple interfaces. To
    generate an include statement for every interface within a module, a Jinja for loop is used:

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus/plugin.cpp.tpl
    \skipto {% for
    \printuntil {% endfor

    Afterwards we continue to define the constructor for our plugin and also use a for loop to fill
    the \c m_instances vector with backend class instances.

    In addition, for the plugin to work correctly the \c interfaces() and \c interfaceInstance()
    methods need to be implemented. The \c interfaces() method needs to return a list of interfaces
    it provides. For this also a Jinja for loop is used. Inside the for loop, Jinja if statements
    are used to decide whether some extra content needs to be printed at the beginning and the end
    of the loop.

    The full plugin definition now looks like this:

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus/plugin.cpp.tpl
    \skipto {{class}}
    \printuntil

    \section3 backend.h.tpl and backend.cpp.tpl

    The backend class files follow the same schema as the plugin. All fetch methods are generated
    using a loop like this:

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus/backend.h.tpl
    \skipto {% for
    \printuntil {% endfor

    In a similar fashion the slots for changed values are generated. But as those take the property
    as an argument we need to generate this part as well.
    This is done by using a filter called \l parameter_type, which takes care of that.

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus/backend.h.tpl
    \skipuntil public Q_SLOTS:
    \printuntil {% endfor

    Lastly, a for loop also needs to be used to generate all the member variables. To convert the
    QFace IDL type of the property to the correct C++ type, we use the \l return_type filter.

    In the source file, we register all enums and structs using \l qDBusRegisterMetaType and
    replace the hardcoded \c propertyChanged method calls in the \c initialize() function with a Jinja
    for loop.

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus/backend.cpp.tpl
    \skipto {{class}}
    \printto void {{class}}::setupConnection()

    The rest of the code is ported accordingly and looks like this:

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus/backend.cpp.tpl
    \skipto void {{class}}::setupConnection()
    \printto

    \section3 plugin.json

    For the plugin to be loaded correctly we also need to generate the \c plugin.json file, which is
    done like this:

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus/plugin.json.tpl
    \skipuntil #}
    \printto

    \section2 Add new Annotations

    If you did the exercise to port all the files by yourself, you might have noticed that not
    everything in the backend code can be derived from the QFace module or interface names.

    As we still want to use the DBus interface generated by \l qdbusxml2cpp, the class name and dbus
    interface name are given by the \c instrumentcluster.xml file and once we add an additional
    interface to the IDL file we also need an DBus XML for that.

    That means, we need additional information for every interface in our IDL file. This can be
    achieved by adding a new annotation to the interface:

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/instrument-cluster.qface
    \skipto @config_dbus
    \printuntil interface InstrumentCluster
    \dots

    Now as the information is part of the IDL file, we can also access it in the template like this:

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus/backend.cpp.tpl
    \skipto m_client =
    \printuntil m_client =

    \section2 Finalize the template

    To finalize the template we need to create some more files.

    \section3 Build-system template files

    Right now ifcodegen supports both QMake and CMake as build systems. For each one we need to
    provide additional files to let the build system know how to generate and compile our code.

    For QMake we add a \c plugin.pri.tpl:

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus/plugin.pri.tpl
    \skipuntil #}
    \printto

    There we add all the generated C++ files to the \c HEADERS and \c SOURCES variables
    accordingly. Afterwards we add some extra code to generate the DBus interface for every
    interface in our module.

    You might wonder, why the actual file names differ from the template names? We will explain
    that after we had a look at the CMake integration:

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus/CMakeLists.txt.tpl
    \skipuntil #}
    \printto

    For CMake it works a bit different, as ifcodegen provides two different mechanisms to
    integrate. First all the needed information is saved as ifcodegen variables using a call to
    \l qt6_set_ifcodegen_variable. All variables have to be prefixed with \c {${VAR_PREFIX}_}. The
    \c VAR_PREFIX variable is set by CMake when importing the file and is used to import the
    variables using \l qt_ifcodegen_import_variables.

    The second way to integrate with CMake is \l qt_ifcodegen_extend_target. In that case the
    \c ${CURRENT_TARGET} variable is set and the previous defined variables are used to call the
    needed cmake functions, e.g:

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus/CMakeLists.txt.tpl
    \skipto target_sources
    \printuntil )

    \section3 Create a Generation YAML file

    One important piece of information is still missing in order for ifcodegen to generate
    something useful. It doesn't know how the generated files should be named or whether a file
    should only be generated once or per module.

    All this is defined within the \l {Generation YAML} file, which is named after the template and
    is located within the same directory:

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus.yaml
    \printto

    First the YAML defines that for every module in the IDL file some files should be generated.
    Every document consists of the output file name (using \l {Jinja Template Syntax} {Jinja
    syntax}), followed by the input template file name.

    The same is done for all files which should be generated for every interface in the IDL file:

    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/templates/backend_dbus.yaml
    \skipto interface:
    \printto

    \section2 Use the new template in the build system

    In order to use the new template, you need to integrate it into the build system:

    \e CMake:
    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/backend_dbus/CMakeLists.txt
    \skipto qt_ifcodegen_extend_target
    \printuntil )

    \e QMake:
    \quotefromfile interfaceframework/qface-tutorial/ch7-own-template/backend_dbus/backend_dbus.pro
    \skipto IFCODEGEN_TEMPLATE
    \printuntil IFCODEGEN_SOURCES

    Instead of just using the template name, you need to provide the full path to the template, or
    add the template folder to the \l {cmake-variable-QT_IFCODEGEN_TEMPLATE_SEARCH_PATH}{template search path}.
*/
